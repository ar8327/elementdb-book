<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>第 4 章 查询语言 | ElementDB the Book</title>
  <meta name="description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  <meta name="generator" content="bookdown 0.37 and GitBook 2.6.7" />

  <meta property="og:title" content="第 4 章 查询语言 | ElementDB the Book" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  <meta name="github-repo" content="ar8327/elementdb-book" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="第 4 章 查询语言 | ElementDB the Book" />
  
  <meta name="twitter:description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  

<meta name="author" content="ar8327" />


<meta name="date" content="2024-02-13" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="intro-to-dbms.html"/>
<link rel="next" href="intro-to-store.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

<link rel="stylesheet" href="css/style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">ElementDB the Book</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> 序言</a></li>
<li class="chapter" data-level="2" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>2</b> 问题引入</a>
<ul>
<li class="chapter" data-level="2.1" data-path="intro.html"><a href="intro.html#building-a-employee-management-system"><i class="fa fa-check"></i><b>2.1</b> 构建一个员工信息管理系统</a>
<ul>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#存储的逻辑结构"><i class="fa fa-check"></i>存储的逻辑结构</a></li>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#系统支持的功能"><i class="fa fa-check"></i>系统支持的功能</a></li>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#系统的简易实现"><i class="fa fa-check"></i>系统的简易实现</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="intro.html"><a href="intro.html#problems-building-simple-db"><i class="fa fa-check"></i><b>2.2</b> 员工信息管理系统的问题</a>
<ul>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#与物理存储结构绑定的查询和写入逻辑"><i class="fa fa-check"></i>与物理存储结构绑定的查询和写入逻辑</a></li>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#缺乏并发控制读写操作互相排斥"><i class="fa fa-check"></i>缺乏并发控制，读写操作互相排斥</a></li>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#数据持久化与数据完整性检查"><i class="fa fa-check"></i>数据持久化与数据完整性检查</a></li>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#缺乏唯一索引约束能力"><i class="fa fa-check"></i>缺乏唯一索引约束能力</a></li>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#性能问题"><i class="fa fa-check"></i>性能问题</a></li>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#缺乏字段类型数据格式和存储低效"><i class="fa fa-check"></i>缺乏字段类型、数据格式和存储低效</a></li>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#缺乏表结构灵活性"><i class="fa fa-check"></i>缺乏表结构灵活性</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="intro-to-dbms.html"><a href="intro-to-dbms.html"><i class="fa fa-check"></i><b>3</b> DBMS简介</a>
<ul>
<li class="chapter" data-level="3.1" data-path="intro-to-dbms.html"><a href="intro-to-dbms.html#brief-history-of-dmbs"><i class="fa fa-check"></i><b>3.1</b> 数据库系统发展简史</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="intro-to-dbms.html"><a href="intro-to-dbms.html#datamodel"><i class="fa fa-check"></i><b>3.1.1</b> 数据模型</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="intro-to-dbms.html"><a href="intro-to-dbms.html#modules-of-dbms"><i class="fa fa-check"></i><b>3.2</b> 数据库系统的模块</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="intro-to-dbms.html"><a href="intro-to-dbms.html#frontend-of-dbms"><i class="fa fa-check"></i><b>3.2.1</b> 数据库的前端</a></li>
<li class="chapter" data-level="3.2.2" data-path="intro-to-dbms.html"><a href="intro-to-dbms.html#backend-of-dbms"><i class="fa fa-check"></i><b>3.2.2</b> 数据库的后端</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="query-language.html"><a href="query-language.html"><i class="fa fa-check"></i><b>4</b> 查询语言</a>
<ul>
<li class="chapter" data-level="4.1" data-path="query-language.html"><a href="query-language.html#query-language-and-data-models"><i class="fa fa-check"></i><b>4.1</b> 数据模型与查询语言</a>
<ul>
<li class="chapter" data-level="4.1.1" data-path="query-language.html"><a href="query-language.html#hierarchical-model"><i class="fa fa-check"></i><b>4.1.1</b> 层次(Hierarchical model)模型</a></li>
<li class="chapter" data-level="4.1.2" data-path="query-language.html"><a href="query-language.html#relational-model"><i class="fa fa-check"></i><b>4.1.2</b> 关系模型</a></li>
<li class="chapter" data-level="4.1.3" data-path="query-language.html"><a href="query-language.html#document-model"><i class="fa fa-check"></i><b>4.1.3</b> 文档模型</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="query-language.html"><a href="query-language.html#designing-a-pseudo-sql"><i class="fa fa-check"></i><b>4.2</b> 定义自己的简单类SQL语言</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="query-language.html"><a href="query-language.html#intro-to-compiler-design"><i class="fa fa-check"></i><b>4.2.1</b> 一点点的编译原理小知识</a></li>
<li class="chapter" data-level="4.2.2" data-path="query-language.html"><a href="query-language.html#lexical-analysis"><i class="fa fa-check"></i><b>4.2.2</b> 词法分析</a></li>
<li class="chapter" data-level="4.2.3" data-path="query-language.html"><a href="query-language.html#syntactic-analysis"><i class="fa fa-check"></i><b>4.2.3</b> 语法分析</a></li>
<li class="chapter" data-level="4.2.4" data-path="query-language.html"><a href="query-language.html#semantic-analysis"><i class="fa fa-check"></i><b>4.2.4</b> 语义分析</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="query-language.html"><a href="query-language.html#implementing-a-sql-parser"><i class="fa fa-check"></i><b>4.3</b> 实现一个简单SQL解析器</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="query-language.html"><a href="query-language.html#top-down-parser"><i class="fa fa-check"></i><b>4.3.1</b> 自顶向下的语法解析器</a></li>
<li class="chapter" data-level="4.3.2" data-path="query-language.html"><a href="query-language.html#intro-to-bnf"><i class="fa fa-check"></i><b>4.3.2</b> BNF范式的基本概念</a></li>
<li class="chapter" data-level="4.3.3" data-path="query-language.html"><a href="query-language.html#generating-a-ast-from-bnf"><i class="fa fa-check"></i><b>4.3.3</b> 根据BNF范式生成AST的过程</a></li>
<li class="chapter" data-level="4.3.4" data-path="query-language.html"><a href="query-language.html#LL-1-parser"><i class="fa fa-check"></i><b>4.3.4</b> LL(1)解析器</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="intro-to-store.html"><a href="intro-to-store.html"><i class="fa fa-check"></i><b>5</b> 存储基础</a>
<ul>
<li class="chapter" data-level="5.1" data-path="intro-to-store.html"><a href="intro-to-store.html#harddrives-and-os"><i class="fa fa-check"></i><b>5.1</b> 硬盘与操作系统</a>
<ul>
<li class="chapter" data-level="5.1.1" data-path="intro-to-store.html"><a href="intro-to-store.html#how-os-recongize-hdds"><i class="fa fa-check"></i><b>5.1.1</b> 操作系统如何认识硬盘</a></li>
<li class="chapter" data-level="5.1.2" data-path="intro-to-store.html"><a href="intro-to-store.html#abstraction-of-hdds"><i class="fa fa-check"></i><b>5.1.2</b> 操作系统对硬盘的抽象</a></li>
<li class="chapter" data-level="5.1.3" data-path="intro-to-store.html"><a href="intro-to-store.html#block-device"><i class="fa fa-check"></i><b>5.1.3</b> 块设备(Block device)</a></li>
</ul></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Compiled with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">ElementDB the Book</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="query-language" class="section level1 hasAnchor" number="4">
<h1><span class="header-section-number">第 4 章</span> 查询语言<a href="query-language.html#query-language" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="query-language-and-data-models" class="section level2 hasAnchor" number="4.1">
<h2><span class="header-section-number">4.1</span> 数据模型与查询语言<a href="query-language.html#query-language-and-data-models" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><strong>要设计一个数据库系统，第一步就是设计其对外的接口——外界要如何操作数据库中的数据，如何查找数据？</strong></p>
<p>要解决这个问题，首先要定义一种数据模型。</p>
<p>数据模型主要包括两个部分：<strong>其一，其定义了数据在数据库中的逻辑表示，其二，其定义了外界操作数据的法则。</strong></p>
<p>数据模型的意义在于，通过定义一套数据模型，我们可以用指定的语言描述我们想要的数据，剩下的工作就全部可以交给数据库系统进行，而不用我们关心。</p>
<div class="figure"><span style="display:block;" id="fig:query-language"></span>
<img src="images/query-language/query-language.png" alt="查询语言" width="75%" />
<p class="caption">
图 4.1: 查询语言
</p>
</div>
<p>历史上，有非常多的数据模型，在此，我简单介绍几种。</p>
<div id="hierarchical-model" class="section level3 hasAnchor" number="4.1.1">
<h3><span class="header-section-number">4.1.1</span> 层次(Hierarchical model)模型<a href="query-language.html#hierarchical-model" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>在层次模型里，数据是通过类似树的形式组织的。</p>
<p>IBM 的 IMS 最先使用的是层级模型，IBM 为之开发了一种独特的数据查询语言，名为 <em>DL/I</em> (Data Language/One)。
下面是几个 <em>DL/I</em> 的例子：</p>
<pre><code>GET CUSTOMERS BY NAME = &#39;SMITH&#39;
  GIVE ADDRESS PHONE</code></pre>
<p>在这里，<code>GET</code> 是 <em>DL/I</em> 的关键词，它表示要从 <code>CUSTOMERS</code> 这一数据集中获取数据。</p>
<p><code>BY</code> 在这里也是一个关键词，表示要使用的筛选条件，最后，<code>GIVE</code> 关键词表示返回的数据中仅需要 <code>ADDRESS</code> 和 <code>PHONE</code> 这两个字段。</p>
<p>上面这个例子还不能很好地说明数据的层次结构，下面这个例子能够更好地说明这一点：</p>
<p>考虑你需要获取所有状态为 <code>PENDING</code> 的订单号和它对应的顾客姓名，你可以使用下面的语句：</p>
<pre><code>GET ORDERS BY STATUS = &#39;PENDING&#39;
  GIVE ORDER-ID CUSTOMER-NAME</code></pre>
<p>通过上面两个例子，你应该可以发现，在 <em>DL/I</em> 中，数据是按照一棵树的形式展开的，<code>ORDERS</code> 表的结构大致如下：</p>
<pre><code>ORDERS
  ORDER-ID (integer)
  CUSTOMER-NAME (string)
  STATUS (string)</code></pre>
<p>而 <code>CUSTOMER</code> 则是上文中我们提到的另一个表：</p>
<pre><code>CUSTOMERS
  NAME (string)
  ADDRESS (string)
  PHONE (string)</code></pre>
<p>尽管在查询时通过这种方式来处理一对多关系非常便利，但由于其表示多对多关系时存在困难，且维护记录与记录的关系十分麻烦（记录与记录之间通过类似指针的方式关联，因此在更新时需要考虑非常多的内容），<strong>这种数据模型在70年代后逐渐被关系模型和 SQL 取代。</strong></p>
</div>
<div id="relational-model" class="section level3 hasAnchor" number="4.1.2">
<h3><span class="header-section-number">4.1.2</span> 关系模型<a href="query-language.html#relational-model" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>关系模型是非常重要的模型，时至今日，关系模型及其衍生物 SQL 依然非常流行。</p>
<p>关系模型最初是在 <em>A relational model of data for large shared data banks</em> 这篇论文中由 IBM研究院 在 70 年代提出的，一个数据模型具有如此长久的生命力是非常不可思议的，恰恰说明了关系模型真的解决了之前的诸多问题。</p>
<p>在这篇文章中，作者首先指出了当时存在的层次模型与网络模型的诸多缺点，并提出了关系模型希望取而代之。有兴趣的读者可以进行阅读。<strong>上述模型的最重要缺陷之一是由于其对用户暴露了过多数据存储的细节(指针)，进而引入了极大的编程复杂性</strong>，因此，关系模型在设计之初的核心思想就是这是一个声明式的模型，不会把关于数据存储的详细信息暴露给用户。</p>
<p>关系模型中，定义了 关系(relations) 和对 关系 的一系列 操作(operations) ，这些简单的操作可以叠加，从而形成复杂的关系表达能力。
3 个基本的关系操作是：</p>
<ul>
<li>选择操作，可以选择关系中符合对应条件的记录。例如，以下表达式可以选择 <code>Employees</code> 中所有 <code>Salary</code> 大于 50000 的记录。</li>
</ul>
<pre><code>σ Salary &gt; 50000 (Employees)</code></pre>
<ul>
<li>投影操作: 投影操作可以从关系集合中选择一部分列。
例如，下面的表达式可以表示从 <code>Employees</code> 数据集中选择记录的 <code>Name</code> 和 <code>Salary</code> 字段。</li>
</ul>
<pre><code>π Name, Salary (Employees)</code></pre>
<ul>
<li>连接: 连接操作可以将 2 个关系集合并成一个，通过指定连接字段，可以将拥有相同连接字段值的关系联合起来。例如，下面的表达式可以将 <code>Employees</code> 和 <code>Departments</code> 这 2 个关系通过 <code>DepartmentID</code> 连接起来。</li>
</ul>
<pre><code>Employees ⨝ DepartmentID = DepartmentID (Departments)</code></pre>
<div id="sql" class="section level4 hasAnchor" number="4.1.2.1">
<h4><span class="header-section-number">4.1.2.1</span> SQL<a href="query-language.html#sql" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>SQL 是随着关系模型被提出的，SQL是自然语言化的关系代数表达式。例如，上面的 3 个关系代数表达式对应的 SQL 语句分别是:</p>
<pre><code>SELECT * FROM Employees WHERE Salary &gt; 50000;
SELECT Name, Salary FROM Employees;
SELECT * FROM Employees INNER JOIN Departments ON Employees.DepartmentID = Departments.DepartmentID;</code></pre>
</div>
</div>
<div id="document-model" class="section level3 hasAnchor" number="4.1.3">
<h3><span class="header-section-number">4.1.3</span> 文档模型<a href="query-language.html#document-model" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>最后，在结束之前，再介绍一种随着 <em>noSQL</em> (Not Only SQL)发展普遍被使用的模型——文档模型。</p>
<p>在一个文档模型的数据库中，你可以认为是一个 数据库(bucket) 中保存了 n 个 JSON ，一个数据库是一个 JSON 的 桶(bucket) ，每个 JSON 就是一条记录。这些 JSON 之间不需要有相同的结构，对 JSON 的大小等都没有限制。</p>
<p><strong>与文档模型相比，关系模型要求一切都被定义好</strong>，所有的关系都必须预先定义好自己的 schema(列和列的类型) ，如果没有预先定义，那么这个列就无法被搜索和单独访问。然而，随着计算机软件的发展，出现了一些并不适合预先定义好 schema 的数据，另外，文档模型由于是一个 非归一化(denormalized) 的模型，记录与记录之间不会互相依赖，只需要保证单个文档的准确性，也不需要支持传统关系型数据库那样多个表之间的事务保证，在分布式部署等方面具有原生的优势，通常更益于并行计算，能够获得更大的性能收益。</p>
<div id="comparsion-between-hierarchical-model-and-document-model" class="section level4 hasAnchor" number="4.1.3.1">
<h4><span class="header-section-number">4.1.3.1</span> 层次模型与文档模型的比较<a href="query-language.html#comparsion-between-hierarchical-model-and-document-model" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>读者可能会觉得文档模型与层次模型有不少相似之处，尤其是他们可以不加限制地嵌套记录这一点。</p>
<p>确实，层次模型看起来与文档模型有非常多的相似之处，但其中最重要的区别在于，层次模型依然存在记录与记录的关联关系——层次模型不保存非归一化的记录，而是保存指针。这种设计导致了层次模型的失败——维护这些关系过于复杂，经常把系统搞得一团乱麻。相比之下，<strong>文档模型舍弃了指针设计，不允许文档之间互相关联，这种功能上的牺牲极大降低了数据模型的复杂性。</strong>因此，文档模型不会走层次模型的老路。</p>

<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div id="designing-a-pseudo-sql" class="section level2 hasAnchor" number="4.2">
<h2><span class="header-section-number">4.2</span> 定义自己的简单类SQL语言<a href="query-language.html#designing-a-pseudo-sql" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>SQL，即 Structured Query Language ，具有比较强的表达能力，最早在1979年由 Oracle 推向商用数据库市场。
随着关系型数据库的流行， SQL 的影响力日渐庞大，几乎所有的关系型数据库，甚至部分 KV数据库 、 列数据库 也支持 SQL 或 SQL方言 作为数据查询语言和操作语言。</p>
<p>接下来，为了实现我们自己的数据库，我们也需要为我们的数据库选择一种用于操作数据和查询数据的语言。这里，我选择了一种简化的 SQL 语言。这篇文章主要介绍如何定义这种语言。</p>
<div id="intro-to-compiler-design" class="section level3 hasAnchor" number="4.2.1">
<h3><span class="header-section-number">4.2.1</span> 一点点的编译原理小知识<a href="query-language.html#intro-to-compiler-design" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>首先，不妨思考这个问题：<strong>如何定义一句 SQL 语句是否合理？如何设计我们自己的 SQL 语法？</strong></p>
<p>一个答案是使用 BNF范式（巴科斯范式）。</p>
<p>在解析一句 SQL 语句是否合法时，主要包括以下三个步骤。</p>
<p>第一步，<strong>词法分析</strong>，这一步中，我们会把用户输入的 SQL 语句分为一个个的 token ，每个 token 都是 BNF 中定义的关键词。</p>
<p>第二步，<strong>语法分析</strong>，在这一步，我们分析 token 的排列规则是否符合预先设定的规则，也就是是否符合我们定义的 BNF范式 的要求。经过语法分析后，我们能得到一些结构化的数据，这些结构对应的就是 SQL 语句的解析结果。比较典型的结构体是 Parse Tree 或者 AST (抽象语法树)。</p>
<p>第三步，<strong>语义分析</strong>，这一步中我们要分析已经确定符合 BNF范式 的语句是否存在语义上的缺陷，例如，是否在字符串类型的字段中插入了数字，等等。</p>
<p>下面，我会给一些简单的例子来介绍上面的步骤，并最终给出我们的 SQL 语句 BNF 。</p>
</div>
<div id="lexical-analysis" class="section level3 hasAnchor" number="4.2.2">
<h3><span class="header-section-number">4.2.2</span> 词法分析<a href="query-language.html#lexical-analysis" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>例如，我们有这样一条 SQL 语句: <code>SELECT name FROM students WHERE age &gt; '18';</code></p>
<p>在 <em>词法分析</em> 阶段，我们将该语句分解为以下 token : <code>SELECT</code> , <code>name</code> , <code>FROM</code> , <code>students</code> , <code>WHERE</code> , <code>age</code> , <code>&gt;</code> ,<code>'18'</code> , <code>;</code></p>
<p>相信你也明白所谓的 <em>词法分析</em> 的作用了，在这一步中，<strong>我们定义一系列规则，来明确在我们定义的语言中什么样的字符可以连接在一起构成一个 token ，什么样的字符自己就是一个 token ，而什么样的字符是非法的。</strong></p>
<p>具体来说，怎么定义 token 呢？接下来是定义 token 的方法</p>
<div id="defination-of-token" class="section level4 hasAnchor" number="4.2.2.1">
<h4><span class="header-section-number">4.2.2.1</span> Token的定义<a href="query-language.html#defination-of-token" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li>关键词</li>
</ul>
<p>诸如 <code>SELECT</code> 、 <code>WHERE</code> 这一类的 token 是我们预先定义好的关键词，这类关键词是可以枚举的</p>
<ul>
<li>比较符</li>
</ul>
<p>诸如 <code>&gt;</code> 这样的字符，自己就可以成为一个单独的 <code>token</code> ，这一类情况和关键词类似，记为 <code>OP</code></p>
<ul>
<li>标识符</li>
</ul>
<p>像是<code>name</code>, <code>students</code> 这些本身都不属于我们语法的一部分，是根据用户所指定的表而变化的，这部分的数据我们可以统称为 <em>标识符</em> ，记为 <code>MARK</code></p>
<ul>
<li>常量</li>
</ul>
<p>虽然上面的 SQL 语句中没有，但我们不难想到，被引号包裹的，里面的内容，不论是不是连续的，中间有没有空格，都是常量，记为 <code>CONST</code></p>
</div>
<div id="result-of-lexcal-analysis" class="section level4 hasAnchor" number="4.2.2.2">
<h4><span class="header-section-number">4.2.2.2</span> 词法分析结果<a href="query-language.html#result-of-lexcal-analysis" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>最后，在定义了上面这些 token 之后，展示 <em>词法分析</em> 的具体结果</p>
<p>从形式上来说，<code>SELECT name FROM students WHERE age &gt; 18;</code> 可以解析成：</p>
<p><code>&lt;SELECT&gt;</code>, <code>&lt;MARK&gt;</code>, <code>&lt;FROM&gt;</code>, <code>&lt;MARK&gt;</code>, <code>&lt;WHERE&gt;</code>, <code>&lt;MARK&gt;</code>, <code>&lt;OP&gt;</code>, <code>&lt;CONST&gt;</code>, <code>&lt;END&gt;</code></p>
<p>而具体来说，每一个形式上的 token 都对应一个具体的值，也就是这样的结果：</p>
<p><code>SELECT</code>, <code>name</code>, <code>FROM</code>, <code>students</code>, <code>WHERE</code>, <code>age</code>, <code>&gt;</code>, <code>18</code>, <code>;</code></p>
</div>
</div>
<div id="syntactic-analysis" class="section level3 hasAnchor" number="4.2.3">
<h3><span class="header-section-number">4.2.3</span> 语法分析<a href="query-language.html#syntactic-analysis" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>有了 <em>词法分析</em> 的结果，就可以在此基础上进行 <em>语法分析</em> 。<em>语法分析</em> 的目的是检查 token 连在一起后是不是能符合我们定义的语法 ，并解析生成 <em>抽象语法树</em></p>
<div id="example-of-bnf" class="section level4 hasAnchor" number="4.2.3.1">
<h4><span class="header-section-number">4.2.3.1</span> BNF范式的例子<a href="query-language.html#example-of-bnf" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>在根据 BNF范式 来解析用户输入时，通常先认为用户输入的内容都属于第一条 BNF范式 ， 随后根据具体情况根据右边的表达式展开即可。</p>
<pre><code>&lt;select-statement&gt; ::= SELECT &lt;column-list&gt; FROM &lt;table-name&gt; WHERE &lt;MARK&gt; &lt;OP&gt; &lt;CONST&gt;;
&lt;column-list&gt; ::= &lt;column-name&gt; | &lt;column-name&gt;, &lt;column-list&gt;
&lt;column-name&gt; ::= &lt;MARK&gt;
&lt;table-name&gt; ::= &lt;MARK&gt;
&lt;MARK&gt; ::= &lt;letter&gt; {&lt;letter-or-digit&gt;}
&lt;CONST&gt; ::= &#39;&lt;MARK&gt;&#39;
&lt;OP&gt; ::= &lt; | = | &gt; | &lt;= | &gt;= | !=
&lt;letter&gt; ::= a | b | c | ... | z | A | B | C | ... | Z
&lt;letter-or-digit&gt; ::= &lt;letter&gt; | &lt;digit&gt;
&lt;digit&gt; ::= 0 | 1 | 2 | ... | 9</code></pre>
<p>上面是一个很简单的 BNF 例子，这个例子可以解析上面给出的 SQL 语句</p>
<p>当然了，它也有不少不足，举例来说，上面我们给出的 BNF范式 只能解析含有一个 WHERE 条件的 SELECT 语句， BNF 是表现力很强的语言，我们可以稍作修改，让我们定义的 SELECT 语句支持任意多个 WHERE 条件：</p>
<pre><code>&lt;select-statement&gt; ::= SELECT &lt;column-list&gt; FROM &lt;table-name&gt; WHERE &lt;condition&gt;
&lt;column-list&gt; ::= &lt;column-name&gt; | &lt;column-list&gt;, &lt;column-name&gt;
&lt;column-name&gt; ::= &lt;MARK&gt;
&lt;table-name&gt; ::= &lt;MARK&gt;
&lt;condition&gt; ::= &lt;expression&gt; | &lt;condition&gt; &lt;logical-op&gt; &lt;expression&gt;
&lt;expression&gt; ::= &lt;MARK&gt; &lt;OP&gt; &lt;CONST&gt;
&lt;logical-op&gt; ::= AND | OR
&lt;OP&gt; ::= &quot;=&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot; | &quot;!=&quot;
&lt;MARK&gt; ::= &lt;letter&gt; {&lt;letter-or-digit&gt;}
&lt;CONST&gt; ::= &#39;&lt;string&gt;&#39;
&lt;string&gt; ::= {&lt;letter-or-digit&gt;}
&lt;letter&gt; ::= a | b | c | ... | z | A | B | C | ... | Z
&lt;letter-or-digit&gt; ::= &lt;letter&gt; | &lt;digit&gt;
&lt;digit&gt; ::= 0 | 1 | 2 | ... | 9</code></pre>
<p>上面的例子里给出了一个支持任意多个 WHERE 条件的 SELECT 语句的 BNF范式</p>
<p>在这篇文章中，我暂时不会给出 BNF范式 应该如何解读的例子，希望读者反复研读上面给出的 2 则例子，对 BNF范式 建立一个大概的印象和理解。</p>
<p><strong>如果读者阅读 BNF范式 时发现很难完全理解 BNF范式 的意义，在下一篇文章中会有如何根据 BNF范式 编写程序、解析出 AST 的内容，可以参阅那部分的内容。</strong></p>
</div>
<div id="parsing-with-bnf" class="section level4 hasAnchor" number="4.2.3.2">
<h4><span class="header-section-number">4.2.3.2</span> 根据BNF范式来进行语法解析<a href="query-language.html#parsing-with-bnf" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>仅仅给出 BNF范式 的方式，对没有编译原理基础的读者可能不友好，读者可能不知道应该如何利用 BNF范式 来解析语句，但在这节内容中，我们仅仅强调 BNF范式 定义的语法可以将用户输入的 SQL语句 解析为 AST。</p>
<p>下面，我们做一个将 SELECT 语句最后解析成 AST 的例子：</p>
<p>考虑下面的 SQL 语句：<code>SELECT name FROM students WHERE age &gt; '18' AND gender = 'M';</code></p>
<p>在完成基本的词法分析，将 SQL语句 转化成 token 后，就可以根据 BNF范式 得到以下的 抽象语法树 ：</p>
<pre><code>&lt;select-statement&gt;
    ├── &lt;column-list&gt;
    │       └── &lt;column-name&gt;
    │              └── name
    ├── &lt;table-name&gt;
    │       └── students
    └── &lt;condition&gt;
            ├── &lt;expression&gt;
            │       ├── &lt;MARK&gt;
            │       │      └── age
            │       ├── &lt;OP&gt;
            │       │      └── &gt;
            │       └── &lt;CONST&gt;
            │              └── &#39;18&#39;
            ├── &lt;logical-op&gt;
            │        └── AND
            └── &lt;expression&gt;
                    ├── &lt;MARK&gt;
                    │      └── gender
                    ├── &lt;OP&gt;
                    │      └── =
                    └── &lt;CONST&gt;
                           └── &#39;M&#39;</code></pre>
<p>读者可以发现，AST树 中的所有 <em>叶子结点</em> 都是 BNF范式 中定义的不可继续展开(称为<em>终止符</em>)的，而 AST树 的 <em>根节点</em> 则是第一条 BNF范式。</p>
<p>关于如何根据 BNF 来直接解析出上面这颗 AST 的算法，在本篇文章中暂时不涉及，会在之后的篇幅中给简单介绍。</p>
</div>
</div>
<div id="semantic-analysis" class="section level3 hasAnchor" number="4.2.4">
<h3><span class="header-section-number">4.2.4</span> 语义分析<a href="query-language.html#semantic-analysis" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>在有了 AST 的基础上，可以对 AST 进行 <em>语义分析</em> ，发现 AST 中符合文法逻辑，但不符合逻辑的地方。</p>
<p>例如，<code>name</code> 字段 不存在，<code>students</code> 这一 表 不存在，或者是<code>age</code> 字段 明明是数字类型，比较的值却是字符串，这一类简单的问题都可以通过语义分析来发现。</p>

<div style="page-break-after: always;"></div>
</div>
</div>
<div id="implementing-a-sql-parser" class="section level2 hasAnchor" number="4.3">
<h2><span class="header-section-number">4.3</span> 实现一个简单SQL解析器<a href="query-language.html#implementing-a-sql-parser" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="top-down-parser" class="section level3 hasAnchor" number="4.3.1">
<h3><span class="header-section-number">4.3.1</span> 自顶向下的语法解析器<a href="query-language.html#top-down-parser" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>让我们回忆之前提到过的可以描述 SELECT 语句的 BNF范式 ：</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb22-1"><a href="query-language.html#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span><span class="kw">select</span><span class="op">-</span>statement<span class="op">&gt;</span> :<span class="op">:=</span> <span class="kw">SELECT</span> <span class="op">&lt;</span><span class="kw">column</span><span class="op">-</span><span class="kw">list</span><span class="op">&gt;</span> <span class="kw">FROM</span> <span class="op">&lt;</span><span class="kw">table</span><span class="op">-</span>name<span class="op">&gt;</span> <span class="kw">WHERE</span> <span class="op">&lt;</span>MARK<span class="op">&gt;</span> <span class="op">&lt;</span>OP<span class="op">&gt;</span> <span class="op">&lt;</span>CONST<span class="op">&gt;</span>;</span>
<span id="cb22-2"><a href="query-language.html#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span><span class="kw">column</span><span class="op">-</span><span class="kw">list</span><span class="op">&gt;</span> :<span class="op">:=</span> <span class="op">&lt;</span><span class="kw">column</span><span class="op">-</span>name<span class="op">&gt;</span> | <span class="op">&lt;</span><span class="kw">column</span><span class="op">-</span>name<span class="op">&gt;</span>, <span class="op">&lt;</span><span class="kw">column</span><span class="op">-</span><span class="kw">list</span><span class="op">&gt;</span></span>
<span id="cb22-3"><a href="query-language.html#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span><span class="kw">column</span><span class="op">-</span>name<span class="op">&gt;</span> :<span class="op">:=</span> <span class="op">&lt;</span>MARK<span class="op">&gt;</span></span>
<span id="cb22-4"><a href="query-language.html#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span><span class="kw">table</span><span class="op">-</span>name<span class="op">&gt;</span> :<span class="op">:=</span> <span class="op">&lt;</span>MARK<span class="op">&gt;</span></span>
<span id="cb22-5"><a href="query-language.html#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>MARK<span class="op">&gt;</span> :<span class="op">:=</span> <span class="op">&lt;</span>letter<span class="op">&gt;</span> {<span class="op">&lt;</span>letter<span class="op">-</span><span class="kw">or</span><span class="op">-</span>digit<span class="op">&gt;</span>}</span>
<span id="cb22-6"><a href="query-language.html#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>CONST<span class="op">&gt;</span> :<span class="op">:=</span> <span class="st">&#39;&lt;MARK&gt;&#39;</span></span>
<span id="cb22-7"><a href="query-language.html#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>OP<span class="op">&gt;</span> :<span class="op">:=</span> <span class="op">&lt;</span> | <span class="op">=</span> | <span class="op">&gt;</span> | <span class="op">&lt;=</span> | <span class="op">&gt;=</span> | <span class="op">!=</span></span>
<span id="cb22-8"><a href="query-language.html#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>letter<span class="op">&gt;</span> :<span class="op">:=</span> a | b | c | <span class="op">..</span>. | z | A | B | C | <span class="op">..</span>. | Z</span>
<span id="cb22-9"><a href="query-language.html#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>letter<span class="op">-</span><span class="kw">or</span><span class="op">-</span>digit<span class="op">&gt;</span> :<span class="op">:=</span> <span class="op">&lt;</span>letter<span class="op">&gt;</span> | <span class="op">&lt;</span>digit<span class="op">&gt;</span></span>
<span id="cb22-10"><a href="query-language.html#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>digit<span class="op">&gt;</span> :<span class="op">:=</span> <span class="dv">0</span> | <span class="dv">1</span> | <span class="dv">2</span> | <span class="op">..</span>. | <span class="dv">9</span></span></code></pre></div>
<p>在这篇文章中，我会一步一步介绍如何使用自顶向下的解析方式来根据 BNF范式 解析这句 SQL ：</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb23-1"><a href="query-language.html#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> name <span class="kw">FROM</span> students <span class="kw">WHERE</span> age <span class="op">&gt;</span> <span class="st">&#39;18&#39;</span>;</span></code></pre></div>
</div>
<div id="intro-to-bnf" class="section level3 hasAnchor" number="4.3.2">
<h3><span class="header-section-number">4.3.2</span> BNF范式的基本概念<a href="query-language.html#intro-to-bnf" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>我们首先来回顾一下 BNF范式 ，以这条 BNF范式 为例：</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb24-1"><a href="query-language.html#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span><span class="kw">select</span><span class="op">-</span>statement<span class="op">&gt;</span> :<span class="op">:=</span> <span class="kw">SELECT</span> <span class="op">&lt;</span><span class="kw">column</span><span class="op">-</span><span class="kw">list</span><span class="op">&gt;</span> <span class="kw">FROM</span> <span class="op">&lt;</span><span class="kw">table</span><span class="op">-</span>name<span class="op">&gt;</span> <span class="kw">WHERE</span> <span class="op">&lt;</span>MARK<span class="op">&gt;</span> <span class="op">&lt;</span>OP<span class="op">&gt;</span> <span class="op">&lt;</span>CONST<span class="op">&gt;</span>;</span></code></pre></div>
<p>在这句 BNF范式 的左侧，是一个名为 <code>&lt;select-statement&gt;</code> 的 <strong>非终止符</strong></p>
<p>在 BNF范式 的右侧，是<code>SELECT &lt;column-list&gt; FROM &lt;table-name&gt; WHERE &lt;MARK&gt; &lt;OP&gt; &lt;CONST&gt;;</code>，这是一个 <strong>终止符</strong> 与 <strong>非终止符</strong> 混合的 <strong>展开式</strong> 。</p>
<p>其中，<code>SELECT</code>、<code>FROM</code>、<code>WHERE</code>、<code>;</code> 是 <strong>终止符</strong> ，而 <code>&lt;column-list&gt;</code> <code>&lt;table-name&gt;</code> <code>&lt;MARK&gt;</code> <code>&lt;OP&gt;</code> <code>&lt;CONST&gt;</code> 是 <strong>非终止符</strong> 。</p>
<p>从这些描述中你可以发现，所谓的终止符就是常量，是不可以再向外推导的内容，而非终止符则有其他的 BNF范式 可以继续进行推导。</p>
<p>而在根据 BNF范式 推导用户输入生成 AST 时，我们总有一个起始的状态，在这里 <code>&lt;select-statement&gt;</code> 就是我们的起始状态。</p>
</div>
<div id="generating-a-ast-from-bnf" class="section level3 hasAnchor" number="4.3.3">
<h3><span class="header-section-number">4.3.3</span> 根据BNF范式生成AST的过程<a href="query-language.html#generating-a-ast-from-bnf" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>接下来，我以这句 SQL 为例，演示如何根据 BNF范式 、自顶向下的解析方法来生成 AST ：</p>
<pre><code>SELECT name FROM students WHERE age &gt; &#39;18&#39;;</code></pre>
<div id="generating-tokens" class="section level4 hasAnchor" number="4.3.3.1">
<h4><span class="header-section-number">4.3.3.1</span> 生成token<a href="query-language.html#generating-tokens" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>不难发现，在进行了简单的 <strong>词法分析</strong> 后，上面的 SQL 语句可以解析为下面的这些 token ：</p>
<ul>
<li>SELECT</li>
<li><letter-or-digit>(name)</li>
<li>FROM</li>
<li><letter-or-digit>(students)</li>
<li>WHERE</li>
<li><MARK>(age)</li>
<li><OP>(&gt;)</li>
<li><CONST>(‘18’)</li>
</ul>
</div>
<div id="top-down-parsing" class="section level4 hasAnchor" number="4.3.3.2">
<h4><span class="header-section-number">4.3.3.2</span> 自顶向下解析<a href="query-language.html#top-down-parsing" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>接下来，可以根据 BNF 进行解析，从最顶端的 <strong>非终止符</strong> <code>&lt;select-statement&gt;</code>开始，尝试将输入的 token 匹配到这个 BNF范式 。</p>
<ol style="list-style-type: decimal">
<li><p><code>SELECT</code> 是 <strong>终止符</strong> ，它与输入的第一个 token 匹配，因此消耗这个 token 。</p></li>
<li><p>下一个是 <code>&lt;column-list&gt;</code> ，由于 BNF范式 中存在 <code>&lt;column-list&gt; ::= &lt;column-name&gt; | &lt;column-name&gt;, &lt;column-list&gt;</code> ，它可以继续扩展为 <code>&lt;column-name&gt;</code> ，又可以继续展开为 <code>&lt;MARK&gt;</code> 。这里 <code>&lt;MARK&gt;</code> 可以进一步扩展为 <code>&lt;letter&gt; {&lt;letter-or-digit&gt;}</code> 。在这个例子中，<code>name</code> 与这个模式匹配，所以消耗 token <code>name</code>。</p></li>
<li><p>下一个 <strong>终止符</strong> 是 <code>FROM</code> ，与输入的下一个 token 匹配，所以消耗 token <code>FROM</code>。</p></li>
<li><p>接着是 <code>&lt;table-name&gt;</code> 。我们的输入 token 是 <code>&lt;letter-or-digit&gt;(students)</code> ，它可以匹配为 <code>&lt;table-name&gt;</code> 中的 <code>&lt;MARK&gt;</code> 。此时，<code>students</code> 匹配 <code>&lt;letter&gt; {&lt;letter-or-digit&gt;}</code>，因此消耗 token <code>students</code>。</p></li>
<li><p>接下来的 <strong>终止符</strong> <code>WHERE</code> 与输入的 token 匹配，所以消耗 token <code>WHERE</code> 。</p></li>
<li><p>下一个 <strong>非终止符</strong> 是 <code>&lt;MARK&gt;</code>，与输入的 token <code>&lt;MARK&gt;(age)</code> 匹配，所以消耗 token <code>age</code>。</p></li>
<li><p>下一个 <strong>终止符</strong> <code>&lt;OP&gt;</code> 与输入的 token <code>&lt;OP&gt;(&gt;)</code> 匹配，所以消耗 token <code>&gt;</code>。</p></li>
<li><p>最后，<code>&lt;CONST&gt;</code> 与输入的 token <code>&lt;CONST&gt;('18')</code> 匹配，所以消耗token <code>'18'</code>。</p></li>
</ol>
<p>以上，我们成功地使用 BNF范式 和 自顶向下的解析方法 ，将给定的 SQL 语句解析为一系列的 token ，并与 BNF范式 进行匹配。</p>
</div>
<div id="generating-a-ast" class="section level4 hasAnchor" number="4.3.3.3">
<h4><span class="header-section-number">4.3.3.3</span> 生成AST（抽象语法树）<a href="query-language.html#generating-a-ast" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>基于上述的解析过程，你可以发现，我们从第一条 BNF范式 出发，通过递归下降的方式直到我们将所有的 token 都推导为 <strong>终止符</strong> ，而从这个推导的过程，我们可以构建一个简化的 AST ：</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb26-1"><a href="query-language.html#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span><span class="fu">select</span><span class="op">-</span>statement<span class="op">&gt;</span></span>
<span id="cb26-2"><a href="query-language.html#cb26-2" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span></span>
<span id="cb26-3"><a href="query-language.html#cb26-3" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span><span class="co">-- SELECT</span></span>
<span id="cb26-4"><a href="query-language.html#cb26-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span></span>
<span id="cb26-5"><a href="query-language.html#cb26-5" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span><span class="co">-- &lt;column-list&gt;</span></span>
<span id="cb26-6"><a href="query-language.html#cb26-6" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span>    <span class="op">|</span></span>
<span id="cb26-7"><a href="query-language.html#cb26-7" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span>    <span class="op">|</span><span class="co">-- &lt;column-name&gt;</span></span>
<span id="cb26-8"><a href="query-language.html#cb26-8" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span>         <span class="op">|</span></span>
<span id="cb26-9"><a href="query-language.html#cb26-9" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span>         <span class="op">|</span><span class="co">-- name</span></span>
<span id="cb26-10"><a href="query-language.html#cb26-10" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span></span>
<span id="cb26-11"><a href="query-language.html#cb26-11" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span><span class="co">-- FROM</span></span>
<span id="cb26-12"><a href="query-language.html#cb26-12" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span></span>
<span id="cb26-13"><a href="query-language.html#cb26-13" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span><span class="co">-- &lt;table-name&gt;</span></span>
<span id="cb26-14"><a href="query-language.html#cb26-14" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span>    <span class="op">|</span></span>
<span id="cb26-15"><a href="query-language.html#cb26-15" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span>    <span class="op">|</span><span class="co">-- students</span></span>
<span id="cb26-16"><a href="query-language.html#cb26-16" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span></span>
<span id="cb26-17"><a href="query-language.html#cb26-17" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span><span class="co">-- WHERE</span></span>
<span id="cb26-18"><a href="query-language.html#cb26-18" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span></span>
<span id="cb26-19"><a href="query-language.html#cb26-19" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span><span class="co">-- &lt;condition&gt;</span></span>
<span id="cb26-20"><a href="query-language.html#cb26-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span></span>
<span id="cb26-21"><a href="query-language.html#cb26-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span><span class="co">-- &lt;MARK&gt;</span></span>
<span id="cb26-22"><a href="query-language.html#cb26-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span>    <span class="op">|</span></span>
<span id="cb26-23"><a href="query-language.html#cb26-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span>    <span class="op">|</span><span class="co">-- age</span></span>
<span id="cb26-24"><a href="query-language.html#cb26-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span></span>
<span id="cb26-25"><a href="query-language.html#cb26-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span><span class="co">-- &lt;OP&gt;</span></span>
<span id="cb26-26"><a href="query-language.html#cb26-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span>    <span class="op">|</span></span>
<span id="cb26-27"><a href="query-language.html#cb26-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span>    <span class="op">|</span><span class="co">-- &gt;</span></span>
<span id="cb26-28"><a href="query-language.html#cb26-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span></span>
<span id="cb26-29"><a href="query-language.html#cb26-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span><span class="co">-- &lt;CONST&gt;</span></span>
<span id="cb26-30"><a href="query-language.html#cb26-30" aria-hidden="true" tabindex="-1"></a>             <span class="op">|</span></span>
<span id="cb26-31"><a href="query-language.html#cb26-31" aria-hidden="true" tabindex="-1"></a>             <span class="op">|</span><span class="co">-- &#39;18&#39;</span></span></code></pre></div>
<p>这样，通过自顶向下的解析方法和 BNF范式 ，我们将一个 SELECT 语句转化为了 AST ，方便之后的 <strong>语义分析</strong> 和 <strong>代码生成</strong>。</p>
</div>
<div id="python-demo-to-generate-an-ast" class="section level4 hasAnchor" number="4.3.3.4">
<h4><span class="header-section-number">4.3.3.4</span> 用Python实现自顶向下解析Demo<a href="query-language.html#python-demo-to-generate-an-ast" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>上述的过程已经很容易理解，但为了进一步明确，我把解析的过程用 python 代码实现了一下。有需要的读者可以把代码和上面的解析过程进行对照：</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="query-language.html#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Node:</span>
<span id="cb27-2"><a href="query-language.html#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value):</span>
<span id="cb27-3"><a href="query-language.html#cb27-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb27-4"><a href="query-language.html#cb27-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> []</span>
<span id="cb27-5"><a href="query-language.html#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="query-language.html#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_child(<span class="va">self</span>, child):</span>
<span id="cb27-7"><a href="query-language.html#cb27-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children.append(child)</span>
<span id="cb27-8"><a href="query-language.html#cb27-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="query-language.html#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>, level<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb27-10"><a href="query-language.html#cb27-10" aria-hidden="true" tabindex="-1"></a>        ret <span class="op">=</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span> <span class="op">*</span> level <span class="op">+</span> <span class="bu">repr</span>(<span class="va">self</span>.value) <span class="op">+</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb27-11"><a href="query-language.html#cb27-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child <span class="kw">in</span> <span class="va">self</span>.children:</span>
<span id="cb27-12"><a href="query-language.html#cb27-12" aria-hidden="true" tabindex="-1"></a>            ret <span class="op">+=</span> child.<span class="fu">__repr__</span>(level <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb27-13"><a href="query-language.html#cb27-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ret</span>
<span id="cb27-14"><a href="query-language.html#cb27-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-15"><a href="query-language.html#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse(tokens):</span>
<span id="cb27-16"><a href="query-language.html#cb27-16" aria-hidden="true" tabindex="-1"></a>    current_token_index <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb27-17"><a href="query-language.html#cb27-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-18"><a href="query-language.html#cb27-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> consume(expected):</span>
<span id="cb27-19"><a href="query-language.html#cb27-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">nonlocal</span> current_token_index</span>
<span id="cb27-20"><a href="query-language.html#cb27-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> tokens[current_token_index] <span class="op">==</span> expected:</span>
<span id="cb27-21"><a href="query-language.html#cb27-21" aria-hidden="true" tabindex="-1"></a>            current_token_index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb27-22"><a href="query-language.html#cb27-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb27-23"><a href="query-language.html#cb27-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb27-24"><a href="query-language.html#cb27-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-25"><a href="query-language.html#cb27-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parse_mark():</span>
<span id="cb27-26"><a href="query-language.html#cb27-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">nonlocal</span> current_token_index</span>
<span id="cb27-27"><a href="query-language.html#cb27-27" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> Node(tokens[current_token_index])</span>
<span id="cb27-28"><a href="query-language.html#cb27-28" aria-hidden="true" tabindex="-1"></a>        current_token_index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb27-29"><a href="query-language.html#cb27-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node</span>
<span id="cb27-30"><a href="query-language.html#cb27-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-31"><a href="query-language.html#cb27-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parse_op():</span>
<span id="cb27-32"><a href="query-language.html#cb27-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">nonlocal</span> current_token_index</span>
<span id="cb27-33"><a href="query-language.html#cb27-33" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> Node(tokens[current_token_index])</span>
<span id="cb27-34"><a href="query-language.html#cb27-34" aria-hidden="true" tabindex="-1"></a>        current_token_index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb27-35"><a href="query-language.html#cb27-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node</span>
<span id="cb27-36"><a href="query-language.html#cb27-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-37"><a href="query-language.html#cb27-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parse_const():</span>
<span id="cb27-38"><a href="query-language.html#cb27-38" aria-hidden="true" tabindex="-1"></a>        <span class="kw">nonlocal</span> current_token_index</span>
<span id="cb27-39"><a href="query-language.html#cb27-39" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> Node(tokens[current_token_index])</span>
<span id="cb27-40"><a href="query-language.html#cb27-40" aria-hidden="true" tabindex="-1"></a>        current_token_index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb27-41"><a href="query-language.html#cb27-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node</span>
<span id="cb27-42"><a href="query-language.html#cb27-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-43"><a href="query-language.html#cb27-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parse_column_list():</span>
<span id="cb27-44"><a href="query-language.html#cb27-44" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> Node(<span class="st">&#39;column-list&#39;</span>)</span>
<span id="cb27-45"><a href="query-language.html#cb27-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb27-46"><a href="query-language.html#cb27-46" aria-hidden="true" tabindex="-1"></a>            node.add_child(parse_mark())</span>
<span id="cb27-47"><a href="query-language.html#cb27-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> consume(<span class="st">&#39;,&#39;</span>):</span>
<span id="cb27-48"><a href="query-language.html#cb27-48" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb27-49"><a href="query-language.html#cb27-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node</span>
<span id="cb27-50"><a href="query-language.html#cb27-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-51"><a href="query-language.html#cb27-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parse_table_name():</span>
<span id="cb27-52"><a href="query-language.html#cb27-52" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span>  Node(<span class="st">&#39;table-name&#39;</span>)</span>
<span id="cb27-53"><a href="query-language.html#cb27-53" aria-hidden="true" tabindex="-1"></a>        node.add_child(parse_mark())</span>
<span id="cb27-54"><a href="query-language.html#cb27-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node</span>
<span id="cb27-55"><a href="query-language.html#cb27-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-56"><a href="query-language.html#cb27-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parse_where():</span>
<span id="cb27-57"><a href="query-language.html#cb27-57" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> Node(<span class="st">&#39;Where&#39;</span>)</span>
<span id="cb27-58"><a href="query-language.html#cb27-58" aria-hidden="true" tabindex="-1"></a>        mark <span class="op">=</span> Node(<span class="st">&#39;Mark&#39;</span>)</span>
<span id="cb27-59"><a href="query-language.html#cb27-59" aria-hidden="true" tabindex="-1"></a>        mark.add_child(parse_mark())</span>
<span id="cb27-60"><a href="query-language.html#cb27-60" aria-hidden="true" tabindex="-1"></a>        op <span class="op">=</span> Node(<span class="st">&#39;OP&#39;</span>)</span>
<span id="cb27-61"><a href="query-language.html#cb27-61" aria-hidden="true" tabindex="-1"></a>        op.add_child(parse_op())</span>
<span id="cb27-62"><a href="query-language.html#cb27-62" aria-hidden="true" tabindex="-1"></a>        const <span class="op">=</span> Node(<span class="st">&#39;Const&#39;</span>)</span>
<span id="cb27-63"><a href="query-language.html#cb27-63" aria-hidden="true" tabindex="-1"></a>        const.add_child(parse_const())</span>
<span id="cb27-64"><a href="query-language.html#cb27-64" aria-hidden="true" tabindex="-1"></a>        node.add_child(mark)</span>
<span id="cb27-65"><a href="query-language.html#cb27-65" aria-hidden="true" tabindex="-1"></a>        node.add_child(op)</span>
<span id="cb27-66"><a href="query-language.html#cb27-66" aria-hidden="true" tabindex="-1"></a>        node.add_child(const)</span>
<span id="cb27-67"><a href="query-language.html#cb27-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node</span>
<span id="cb27-68"><a href="query-language.html#cb27-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-69"><a href="query-language.html#cb27-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parse_select_statement():</span>
<span id="cb27-70"><a href="query-language.html#cb27-70" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 解析入口</span></span>
<span id="cb27-71"><a href="query-language.html#cb27-71" aria-hidden="true" tabindex="-1"></a>        root <span class="op">=</span> Node(<span class="st">&#39;select-statement&#39;</span>)</span>
<span id="cb27-72"><a href="query-language.html#cb27-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> consume(<span class="st">&#39;SELECT&#39;</span>):</span>
<span id="cb27-73"><a href="query-language.html#cb27-73" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&quot;Expected &#39;SELECT&#39;&quot;</span>)</span>
<span id="cb27-74"><a href="query-language.html#cb27-74" aria-hidden="true" tabindex="-1"></a>        root.add_child(parse_column_list())</span>
<span id="cb27-75"><a href="query-language.html#cb27-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> consume(<span class="st">&#39;FROM&#39;</span>):</span>
<span id="cb27-76"><a href="query-language.html#cb27-76" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&quot;Expected &#39;FROM&#39;&quot;</span>)</span>
<span id="cb27-77"><a href="query-language.html#cb27-77" aria-hidden="true" tabindex="-1"></a>        root.add_child(parse_table_name())</span>
<span id="cb27-78"><a href="query-language.html#cb27-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> consume(<span class="st">&#39;WHERE&#39;</span>):</span>
<span id="cb27-79"><a href="query-language.html#cb27-79" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&quot;Expected &#39;WHERE&#39;&quot;</span>)</span>
<span id="cb27-80"><a href="query-language.html#cb27-80" aria-hidden="true" tabindex="-1"></a>        root.add_child(parse_where())</span>
<span id="cb27-81"><a href="query-language.html#cb27-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> root</span>
<span id="cb27-82"><a href="query-language.html#cb27-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-83"><a href="query-language.html#cb27-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parse_select_statement()</span>
<span id="cb27-84"><a href="query-language.html#cb27-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-85"><a href="query-language.html#cb27-85" aria-hidden="true" tabindex="-1"></a><span class="co"># 已经分好的token</span></span>
<span id="cb27-86"><a href="query-language.html#cb27-86" aria-hidden="true" tabindex="-1"></a>tokens <span class="op">=</span> [<span class="st">&#39;SELECT&#39;</span>, <span class="st">&#39;name&#39;</span>, <span class="st">&#39;FROM&#39;</span>, <span class="st">&#39;students&#39;</span>, <span class="st">&#39;WHERE&#39;</span>, <span class="st">&#39;age&#39;</span>, <span class="st">&#39;&gt;&#39;</span>, <span class="st">&quot;&#39;18&#39;&quot;</span>]</span>
<span id="cb27-87"><a href="query-language.html#cb27-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-88"><a href="query-language.html#cb27-88" aria-hidden="true" tabindex="-1"></a><span class="co"># 自顶向下解析</span></span>
<span id="cb27-89"><a href="query-language.html#cb27-89" aria-hidden="true" tabindex="-1"></a>ast <span class="op">=</span> parse(tokens)</span>
<span id="cb27-90"><a href="query-language.html#cb27-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-91"><a href="query-language.html#cb27-91" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ast)</span></code></pre></div>
<p>上面的 python 代码完全复现了之前描述的自顶向下解析过程，根据 <strong>词法分析</strong> 的结果解析出了一颗 <strong>抽象语法树</strong> ，下面是运行的结果：</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="query-language.html#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">&#39;select-statement&#39;</span></span>
<span id="cb28-2"><a href="query-language.html#cb28-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">&#39;column-list&#39;</span></span>
<span id="cb28-3"><a href="query-language.html#cb28-3" aria-hidden="true" tabindex="-1"></a>                <span class="co">&#39;name&#39;</span></span>
<span id="cb28-4"><a href="query-language.html#cb28-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">&#39;table-name&#39;</span></span>
<span id="cb28-5"><a href="query-language.html#cb28-5" aria-hidden="true" tabindex="-1"></a>                <span class="co">&#39;students&#39;</span></span>
<span id="cb28-6"><a href="query-language.html#cb28-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">&#39;Where&#39;</span></span>
<span id="cb28-7"><a href="query-language.html#cb28-7" aria-hidden="true" tabindex="-1"></a>                <span class="co">&#39;Mark&#39;</span></span>
<span id="cb28-8"><a href="query-language.html#cb28-8" aria-hidden="true" tabindex="-1"></a>                        <span class="co">&#39;age&#39;</span></span>
<span id="cb28-9"><a href="query-language.html#cb28-9" aria-hidden="true" tabindex="-1"></a>                <span class="co">&#39;OP&#39;</span></span>
<span id="cb28-10"><a href="query-language.html#cb28-10" aria-hidden="true" tabindex="-1"></a>                        <span class="co">&#39;&gt;&#39;</span></span>
<span id="cb28-11"><a href="query-language.html#cb28-11" aria-hidden="true" tabindex="-1"></a>                <span class="co">&#39;Const&#39;</span></span>
<span id="cb28-12"><a href="query-language.html#cb28-12" aria-hidden="true" tabindex="-1"></a>                        <span class="co">&quot;&#39;18&#39;&quot;</span></span></code></pre></div>
</div>
</div>
<div id="LL-1-parser" class="section level3 hasAnchor" number="4.3.4">
<h3><span class="header-section-number">4.3.4</span> LL(1)解析器<a href="query-language.html#LL-1-parser" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>需要指出，编译原理其实是相对复杂的，这里我们使用的 <strong>语法分析</strong> 方式只是所有语法分析方式中最简单的一种。</p>
<p>具体来说，我们的解析方式总是从左至右解析，并且总是只预读1个 Token ，这样的解析方式被称为 LL(1) ，我们实现的解析器是一个 LL(1) 解析器。</p>
<p>这种方式有它的局限性，例如，它不能处理含有左递归的语法规则，不能处理需要预读 1 个以上 Token 的复杂语法，并且，和自顶向下解析相对应地，也存在自底向上的解析方式，事实上，自底向上的解析方式更能够适应复杂的文法，在业界被广泛使用。</p>

<div style="page-break-after: always;"></div>
</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="intro-to-dbms.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="intro-to-store.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/21-data-model-and-query-language.Rmd",
"text": "编辑"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": {},
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "none"
},
"pandoc_args": "--variable=lang:zh-CN"
});
});
</script>

</body>

</html>
