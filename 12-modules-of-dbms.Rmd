\newpage{}

## 数据库系统的模块 {#modules-of-dbms}

不论数据库系统有哪些功能、实现哪种数据模型，在一些地方始终是相通的。本文介绍数据库系统通常的架构是什么样的。

我们来考虑一个基本的数据库系统，它至少包含以下两个部分：

- 用来处理用户请求的部分

- 用来管理数据存储的部分

通常，第一个部分被称为数据库系统的前端，而第二个部分被称为数据库系统的后端。

接下来， 我们分别考察这两个部分。

### 数据库的前端 {#frontend-of-dbms}

#### 查询解析器 {#query-parser}

这部分需要解析用户输入的命令，判断用户命令的合法性，举例来说：

```sql
FELECT * FROM table1 LIMIT 0,10
```

这句 SQL 命令就不是一句合法的 SQL 命令，因为实际上不存在 `FELECT` 这一关键词

事实上，市面上的大部分数据库前端都会将用户输入的命令解析成抽象语法树 (AST) ，供后端处理，举例来说，下面是一颗解析 SQL 的 AST ：

```
<select-statement>
    ├── <column-list>
    │       └── <column-name>
    │              └── name
    ├── <table-name>
    │       └── students
    └── <condition>
            ├── <expression>
            │       ├── <MARK>
            │       │      └── age
            │       ├── <OP>
            │       │      └── >
            │       └── <CONST>
            │              └── '18'
            ├── <logical-op>
            │        └── AND
            └── <expression>
                    ├── <MARK>
                    │      └── gender
                    ├── <OP>
                    │      └── =
                    └── <CONST>
                           └── 'M'
```

#### 查询优化器 {#query-optimizer}

这部分做的事情主要是对用户输入的查询命令进行一个优化，需要注意的是，在数据库的后端实际上也存在执行计划的优化操作，这部分仅仅讨论的是对 AST 的优化操作。

例如，考虑这么一句 SQL ：

```SQL
SELECT * FROM table1 WHERE col1 >= 10 AND col1 <= 10
```

这句 SQL 实际上可以被等价优化成：

```SQL
SELECT * FROM table1 WHERE col1 = 10
```

这种基于 AST 的纯粹优化有很多好处，举例来说，如果不进行这样的优化，那么数据库后端在执行这个查询的时候大概率在执行的时候是这么执行的：

先找出所有满足 `col1 >= 10` 或者 `col1 <= 10` 的记录，然后检查是否满足其他条件。

这种查询显然是十分低效的，远不如根据 AST 优化后的结果。

### 数据库的后端 {#backend-of-dbms}

#### 系统字典 {#system-dictionary}

数据库系统要对外维持自己的数据模型，就需要维护一些特定的信息。举例来说，如果是一个关系型的数据库，就需要维护自己目前库中有哪些表，表中有什么字段，哪些字段上存在索引这些信息。这一类的信息我们统称为数据库的多数据字典信息，属于是数据库系统自行维护的数据库元信息。数据库很大程度上需要依靠这些元信息来判断查询是否合法，以及如何执行查询。举例来说：当用户需要根据某一条件进行某一查询时，数据库需要根据元信息判断条件字段上是否存在索引，以此来决策具体的执行计划：

```SQL
SELECT * FROM table1 WHERE col1 = 10
```

对于这句查询语句，数据库系统就需要根据元信息来查询这么几个点：

- `table1` 是否存在

- `table1`中有哪些字段

- `table1`的数据存储在哪里

- `col1`上是否有索引

#### 查询计划器 {#query-planner}

查询计划器是所有数据库系统中最为复杂的部分，用于将逻辑上用户需要进行的查询计划转化为物理的执行计划，要明确到需要根据什么查数据，查什么数据，查到了数据之后进行怎么样的处理，具体的算子下沉还是上升等等问题，生成和优化物理执行计划本身是一个NP问题，这也是各个高性能数据库的技术核心。

在用户输入的命令被解析成 AST 并且通过数据字典的基本校验后，就进入到了查询计划器当中。

举例来说，考虑这么一条 SQL ：

```SQL
SELECT * FROM table1 WHERE col1 >= 10 AND col2 <= 10
```

这里其实有三条明显的执行路径：

- 直接扫描全部数据，然后根据条件筛选

- 根据索引拉出所有 `col1 >= 10` 的数据，然后筛选满足 `col2 <= 10` 的

- 根据索引拉出所有 `col2<=10` 的数据，然后筛选满足 `col1>=10` 的

哪个执行方案才是更优的呢？这就需要一些额外的信息辅助判断了：

例如，如果我们知道 `col1>=10` 的数据只有大概 10 条，而 `col2<=10` 的数据有 100000 条，那么显然第二个执行计划是更好的

反之，如果我们知道 `col2<=10` 的数据明显少于 `col1>=10` 的，那么显然第三个执行计划成本就更低

当然，如果说 `col1` 、`col2` 上不存在索引，或者说表的数据量很小，由于 `id` 在我们的数据库里是聚簇索引，不需要回盘查第二次，那可能直接拉所有的数据是更好的

#### 事务管理器、锁管理器、并发控制器 {#dbms}

这一部分，主要是大部分数据库都保有的、为了维持系统正确性、提供并发安全等而提供的机制，如果你的数据库要支持一些并发和隔离特性，那么需要一些额外的组件来支持数据库的正常工作。

这部分是一个比较复杂的问题，举例来说，对于以下2个同时执行的事务：

```SQL
SELECT * FROM table1 WHERE col1 = 10 FOR UPDATE
SELECT * FROM table1 WHERE col2 = 10 FOR UPDATE
SELECT * FROM table1 WHERE col1 = 10 FOR UPDATE
SELECT * FROM table1 WHERE col2 = 10 FOR UPDATE
```

这 2 个事务就会出现互相等待对方释放锁的情况，进而造成死锁，这是不可接受的情况，需要有一个事务主动回滚，才能解决这一问题。

同样地，一些复杂的并发场景需要数据库系统主动识别才能避免问题发生，例如：

```SQL
SELECT id FROM table1 WHERE col1 = 10; -- 事务1，结果id=10
UPDATE table1 SET col1 = col1 + 10 WHERE col1 = 10; -- 事务2，提交
UPDATE table1 SET col1 = (10) + 10 WHERE id = 10; -- 事务1，提交
```

上述的问题就是一个明显的并发问题，事务1读取并使用过期的值来对数据进行更新。

由于这部分的内容相对比较复杂，要系统性的描述需要比较大的篇幅，在之后的内容中会进一步进行讨论。目前仅仅讨论到存在的问题和需要引入解决这些问题的组件。

#### 缓存池 {#bufferpool}

当执行计划被确定之后，就会对硬盘进行大量的 __io操作__ ，理论上，这些 __io操作__ 很可能是随机的，至少也是随机混合的，这一类的读写模式对硬盘不友好，而实际上，即使这种模式对硬盘是友好的，硬盘的数据读取时间对于 CPU 来说也是十分漫长的。

```{r latency-numbers, fig.cap='各种介质的延迟', out.width='75%', echo = FALSE}
knitr::include_graphics('./images/intro-to-dbms/latency-numbers.png')
```

> 图源 https://blog.bytebytego.com/p/ep22-latency-numbers-you-should-know

因此，所有的io操作最好是在内存中进行，由缓存池负责对硬盘的实际io读写调度

#### 索引 {#index}

数据库系统大量需要索引来辅助查找和存储数据，如果没有索引的帮助，数据库系统每次查找数据时只能对所有数据进行遍历，这是不可接受的。而目前常见的两种用于在硬盘数据上建立索引算法是 B树 (包括 B+树 等各种衍生)和 SSTable 。这些算法不仅是要尽可能高校地满足各类查询和插入需求，更重要的是要能够契合硬盘的硬件特性，尽可能减少读取硬盘的次数，一次尽可能多的读取数据而不是多次读取少量数据。

#### 物理文件管理器 {#file-manager}

最后我们要提到的是物理文件管理模块，这里的模块负责的是硬盘空间的管理，这也是一个相对来说有一些复杂的问题。

举例来说，考虑我们需要向数据库存储一份数据，这份数据长 1000 个字节，那么存储引擎就需要考虑几个问题：

- 在哪里存这份数据？空间如何分配？

- 如果有数据最近被删除了，怎么回收之前的数据供使用？

- 怎么样存储数据才能尽可能提高查询效率？

这些问题一定程度上也决定了数据库的性能表现

以上是对数据库系统各个常见模块的一些介绍，这些内容对理解接下来的行文思路会有很大帮助。
