\newpage{}

# 数据库存储层 {#database-storage}

## 存储层的基本设计要素 {#database-storage-design}

在存储基础中，我已经介绍了关于硬盘的一些基础知识，这些知识应该能够帮助读者理解接下来要讨论的数据库的存储层设计。

在这篇文章中，我会简单地设计一个数据库存储数据的物理结构，并简述这种设计背后的一些考量。这种物理结构的设计和前文\@ref(filesystem)中提到过的 FAT32 文件系统的结构会有一些相似之处，如果对本文有不能理解的地方，可以回到上一篇文章去回顾一下 FAT32 的结构。

### 数据库系统对数据存储的需求 {#requirements-of-storage-by-dbms}

从前文介绍的内容中可以看出，相对来说，硬盘的顺序读写的性能通常是随机读写的好几十倍，从这个硬件特性出发，我们涉及存储的核心目标就是，多用顺序读写，少用随机读写，如果一定要随机读写的，最好是能积少成多，尽可能凑成顺序读写。

对应到数据库对硬盘的需求上，一般的数据库对硬盘的读写有2种不同的需求，对应的也有不同的设计方案。

#### 顺序读写，立刻刷盘 {#sequencial-sync}

这种需求常见于数据库系统中存在的各种日志，例如维护事务状态的日志、记录对硬盘进行过的变更的WAL日志等，这一类存储需求的特点是始终都是顺序写入和顺序读取，对缓存几乎没有什么需求，希望写入的数据能立刻落盘。

#### 随机读写，异步刷盘 {#random-async}

这种需求常见于数据库中各种实际上的使用场景，例如，在插入 B+ 树时，新的 B+ 树的节点的物理位置通常没法和之前的邻居紧挨在一起，**这也导致在遍历 B+ 树时实际上可能需要进行随机读取才能读取到下一个节点**。

此外，用户在更新原有的数据时，**很可能是在原有的地方进行修改，这也导致了用户修改数据的请求很可能是一种随机写入**。

**尽管这类需求对硬盘的要求比较苛刻，大部分都是随机读写，但数据库对这一类读写操作的即刻落盘要求不高，通常来说，数据库系统只是要求进行的操作在内存中立即可见，也就是说我们仅仅需要修改缓存，并可以在事后进行异步落盘，这也为优化提供了空间。**

对以上两类不同的读写需求，对应着完全不同的方案。读者也能发现，对于顺序写入，立刻刷盘这种需求来说，我们能做的优化和设计其实并不多，这是一种相对来说简单的读写场景。**本文重点来讨论针对随机读写，异步刷盘的场景如何对数据库的存储层进行设计**。

### 存储层设计的考虑要素 {#design-principles-of-dbms-storage}

#### Data locality {#data-locality}

正如\@ref(ssd-characteristics-and-random-io) 所展现地，**我们的硬盘喜欢读取连续的数据，而非零散的数据。尽管实际上要面对的是随机的读写请求，我们在设计存储层的时候，也要创造机会，从实际上的业务语义出发，通过预留空间等方式，让经常可能被一起读写的数据尽可能相邻。**

#### 空间分配和回收 {#space-allocation-and-recycling}

由于数据是零散的，如何高效分配和回收空间是存储层必须考虑的一个问题。例如，在数据库的使用过程中，用户删除了数据，或者是数据库以前产生的快照已经不再使用，这部分的空间要怎么回收呢？

如果回收不够及时，就会造成空间浪费，同时，由于已经不使用的数据长期占着存储空间，很可能会影响数据局部性。

```{r data-frag, fig.cap='不再使用的数据造成数据碎片影响数据局部性', out.width='75%', echo = FALSE}
knitr::include_graphics('./images/database-storage/data-frag.png')
```


数据库工作的环境是相对高压力的，**需要一种高效、尽可能并行化的方法来管理空间的分配和回收**，尽可能避免出现单点瓶颈。

#### Overflow和变长数据 {#overflow-and-variable-length-data}

另一个很重要的考虑是超长数据和变长数据的存储。**超长数据很可能本身的大小超过了一个最小单元能够存储的大小（类比 FAT32 文件系统中一个簇无法存下的数据）**，这类超长数据的管理是十分复杂的，在 FAT32 中，就使用了链表来管理这部分超长的数据，在回收空间时回需要额外的工作。

另一种很难处理的数据类型是变长数据，变长数据虽然现在能够在一个数据单元中存下，但由于变长的特性，可能之后就无法在这么小的空间里存下了。**支持变长数据的好处是能够节省一些磁盘空间，不必在创建记录的时候就把所有空间都分配完毕**，但日后的管理成本也是巨大的。

可以看到，数据库存储层的设计还是面临很多问题需要考量的。
