[["index.html", "ElementDB the Book e4052dc 第 1 章 序言", " ElementDB the Book e4052dc ar8327 2023-10-15 第 1 章 序言 构建一个数据库是一项庞大、复杂的工作，我也并不是专业有过数据库构建经验的人，所以，我想在文章的开篇就说明白，接下来这些文章的目的、受众以及我将如何展开。 首先，这并不是一份专业性的数据库材料。我会尽可能将我的想法描述清楚，但我描述的内容中可能有不专业、不准确的地方，欢迎指正。这份资料本身的受众是对这些话题有兴趣但没有专业背景的业余爱好者。 再次，这份资料的目的是记录我个人学习数据库相关知识时学习到的知识，以及我自己在实现数据库时自己的思考。我通过将这些知识整理成系统性资料的方式来提高我自身对知识的理解，也能帮助需要的朋友更好地学习。 最后，来介绍一下这份资料的组织形式。 首先聊一聊接下来这些资料的逻辑： 我会先讨论一些关于数据库系统的通用知识，例如什么是事务、什么是 SQL 、什么样的系统是一个数据库系统。在这一过程中，我会尽可能展示这些问题的复杂性，通过展示问题的复杂性，可以让读者对之后解决问题的过程产生兴趣，同时，也有利于激发新的思考。 随后，我会介绍一个数据库系统大致应该有哪些组成部分，各个部分的作用，以及建立一个数据库的模型。在之后，我会详细展开每个部分的理论基础和系统设计，辅以部分实践和杂谈。 我接下来写的资料会大概属于四个分类： 理论，这部分文章会相对严肃一些，阐述一些关于数据库系统的基础理论。例如，要阐述 B+ 树的设计、并发控制机制等，这部分内容会相对干一点，但这是后续所有工作的理论基础，保证我们系统的正确性。 系统设计，这部分在理论的基础上，会讨论在工程上实际实现系统的取舍。同一种理论上的系统模型，有多种实现方式，而不同的实现方式，会产生系统实际性能表现等方面的不同，这就涉及到取舍，是需要重点讨论的。 实践，这部分并不全部是要介绍我写的代码，甚至介绍代码的工作可能只占一小部分，也想设计一些小实验来测试、证实我在文章中所说的观点。我推荐读者也做一下这些实践，可能是自己写一份测试性能的代码，也可能是自己写一个 mmap 的 demo ，通过做这些事情能提高读者的编程能力，这是最基础的能力。 杂谈，杂谈这一块我会发散地讨论一些和数据库系统本身无关，但可能有借鉴价值，或者属于基本素质的内容。 ar8327 2023 年 10 月 "],["intro.html", "第 2 章 问题引入 2.1 构建一个员工信息管理系统 2.2 员工信息管理系统的问题", " 第 2 章 问题引入 2.1 构建一个员工信息管理系统 在动手设计实现数据库之前，不妨先花一点时间头脑风暴一下数据库是什么。 其实，大部分的程序员在编写应用程序的时候，都不会意识到数据库承担了多少工作，这恰恰说明了数据库概念的成功，将数据存储、并发控制、一致性保证等功能从应用中切分出来，并且运用“事务”等概念来实现存储层功能的接口化，是一项了不起的工作。 为了更好地帮助读者认识到数据库的概念，我先从尝试着在不使用数据库的情况下实现一个员工信息管理系统开始，请读者和我一起思考，我们一起分析可能遇到的问题，并且思考数据库是如何解决它们的。 存储的逻辑结构 假设现在我们需要存储一些雇员的信息，这些信息这么定义：员工信息:(姓名, 电话, 年龄) 一条员工信息包括员工的姓名、 员工的电话和员工的年龄。 系统支持的功能 我们的信息管理系统要支持以下功能： 我们要可以插入新的员工信息到系统中，方便为新员工注册信息 我们要可以使用员工姓名查询员工信息，这样公司内的人能够通过姓名查询到他人的信息 为了存储信息，我们可以使用操作系统和文件系统提供的基本文件操作功能，可以在文件系统中创建空白文件，可以向文件中添加信息，也可以从任意位置读取文件。 系统的简易实现 有了上面这些条件，我可以给出一个比较简单的“员工信息管理系统”实现： 在这个实现中，我给每一条记录开启一个新的行，每一行中存储对应的员工信息， 每个员工信息的属性称为一列，每一行含有多个列，分别为员工信息的不同属性 在插入用户信息时，我保证写入的数据都符合这个格式 在查找用户信息时，我根据预先约定好的数据格式去解析数据文件，获取记录的雇员姓名，并返回所有符合要求的记录。 在具体实现上，为了遵循这一协议约定，我使用空文件来存储信息，在行与行之间使用 \\n 分割，同一行的列之间使用 &lt;SEP&gt; 分隔。 下面是一个简单的实现版本： import io class EmployeeManager: def __init__(self): self.DBFILE = &quot;employees.txt&quot; self.db = open(self.DBFILE, &quot;a+&quot;, encoding=&#39;utf-8&#39;) self.SEP = &quot;&lt;SEP&gt;&quot; def write(self, name, phone, age) self.db.seek(0, io.SEEK_END) self.db.write(&quot;{0}{1}{2}{3}{4}{5}\\n&quot;.format(name, self.SEP, phone, self.SEP, age, self.SEP)) self.db.flush() def findByName(self, name): self.db.seek(0) for line in self.db.readlines(): line = line.strip() line = line.split(self.SEP) if line[0] == name: self.db.seek(0) return line self.db.seek(0) return None if __name__ == &#39;__main__&#39;: emp = EmployeeManager() emp.write(&quot;Tom&quot;, &quot;+8613042552664&quot;, 32) emp.write(&quot;Marry&quot;, &quot;+8613142357624&quot;, 29) # Try to find Tom tom = emp.findByName(&quot;Tom&quot;) if tom: print(&quot;Tom exists&quot;) jack = emp.findByName(&quot;Jack&quot;) if jack: print(&quot;Jack exists&quot;) emp.write(&quot;Jack&quot;, &quot;+8613051531&quot;, 34) 最后，我们用一幅图来总结说明刚才我们所做的设计。用两个视图来概括，在文件的物理视图中，我们的文件如右图所示，而在程序和协议中，我们的数据表如左图所示。 图 2.1: 雇员文件逻辑视图 图 2.2: 雇员文件物理视图 2.2 员工信息管理系统的问题 在前文，我们一起实现了一个简单的员工信息管理系统。尽管这个数据库能够满足基本的功能需求，但它不可否认地存在一些缺陷。 在本文中，我会罗列这个信息管理系统可能出现的一些问题，并通过将这些问题分类，来识别数据库系统所做的工作、提供的保证： 与物理存储结构绑定的查询和写入逻辑 没有一种通用的查询语言，每个查找需求都需要编写单独的查找方法 findByName 方法、write 方法都直接与底层的数据存储方式耦合，查找数据的逻辑竟然需要精确到读取第几个字段，这是一种命令式 (imperative) 的做法，与目前的 SQL 语言的声明式查询是相对的，命令式的查询语言将底层实现暴露给最终用户，使得查询语言与底层实现耦合，这在日后是维护的噩梦 缺乏并发控制，读写操作互相排斥 数据库在写入的时候缺乏并发控制，可能出现两个进程同时写入一个文件的情况，造成文件损坏 findByName 方法同样不是并发安全的，可能在一个进程读取文件时另一个进程将文件 rewind 由于直接依赖底层文件的指针位置，读写无法同时进行 数据持久化与数据完整性检查 若在执行 write 方法的时候，flush 的时候系统断电，则会导致数据文件损坏，缺乏错误检查机制 若在执行 write 时，系统完成了 write 操作还没有flush时系统断电，会造成数据完全丢失 缺乏唯一索引约束能力 write 方法缺乏对记录的唯一性校验，如果用户犯错，系统就会写入多条相同的记录 性能问题 findByName 方法异常低效，每次都需要遍历整个文件查找记录，也不具备自己的缓存 缺乏字段类型、数据格式和存储低效 数据文件对数据格式缺乏校验和表示，写入的所有东西都会变成 string 数据文件用的是文本格式，空间效率十分低下 缺乏表结构灵活性 如果要新增一个员工性别字段怎么办？之前的数据如何迁移？ 尽管提出了许多问题，且似乎每一个这些问题都有简单的解决方式，但若要考虑一个能够解决所有问题的方案，似乎问题就会变得复杂。 举例来说，如果是为了解决缺乏唯一索引的问题，我们可以实现一个方法，在写入数据前先遍历整个文件，看看是不是有重复的数据，如果有的话就拒绝写入。但这样的实现也会让写入的性能进一步下降。 那么，有没有什么办法可以比较好地解决上面的全部问题呢？其实是有的。为了解决上面的问题，需要引入现代数据库系统的多个概念。从下一篇文章开始，我就会开始介绍数据库系统中的关键概念，并看看我们如何利用这些工具来解决上面的问题。 "],["intro-to-dbms.html", "第 3 章 DBMS简介 3.1 数据库系统发展简史 3.2 数据库系统的模块", " 第 3 章 DBMS简介 3.1 数据库系统发展简史 在 1960 年代，计算机刚被发明不久，当时计算机远没有普及，软件生态相较今天也十分简单。但在当时，就已经有大型公司尝试着使用计算机来管理数据了。 使用计算机来管理数据有很多好处，相较于传统的纸质数据管理方式，计算机一次性能够记录更多的数据，在数据的检索和管理上也更为容易，存在数据更不容易丢失等优势。 1960 年代主要的数据库系统是以 IDS 为代表的层级数据库。这么说可能会让读者没有概念，因此，为了描述数据库系统，我首先展开一下数据库系统的几个基本概念。 3.1.1 数据模型 所有的数据存储都依赖一个事先定义好的数据模型。以大家熟悉的 MySQL 举例，MySQL 是一种关系型数据库管理系统 (Relational DBMS) 。 MySQL 的数据模型是基于关系代数建立的，在 MySQL 中，所有的数据都从属于一个“表”，这个“表”可以与其他“表”进行关系代数运算。这就是一种非常典型的数据模型。 3.1.1.1 层级数据库 最早期的数据库大部分都是层级数据库 (Hierarchical Database)，在层级数据库中，所有的数据都是按照层级组织的。通常来说，这种类型的数据库中都有一个根结点，当用户需要寻找什么数据的时候，需要手动操作数据库，从根结点出发，定位到自己想要的数据。 举例来说，如果要存储书和作者的关系，可能看起来是下面这样： RECORD Author AuthorID: INTEGER Name: STRING Birthdate: DATE Books: SET OF Book RECORD Book BookID: INTEGER Title: STRING PublicationDate: DATE Author: REFERENCE TO Author // 定义作者 AUTHOR_1 = Author(AuthorID=1, Name=&quot;J.K. Rowling&quot;, Birthdate=&quot;31/07/1965&quot;) AUTHOR_2 = Author(AuthorID=2, Name=&quot;George Orwell&quot;, Birthdate=&quot;25/06/1903&quot;) // 定义书 BOOK_1 = Book(BookID=1, Title=&quot;Harry Potter and the Sorcerer&#39;s Stone&quot;, PublicationDate=&quot;26/06/1997&quot;, Author=AUTHOR_1) BOOK_2 = Book(BookID=2, Title=&quot;1984&quot;, PublicationDate=&quot;08/06/1949&quot;, Author=AUTHOR_2) // 通过这种方式将作者和书链接起来 AUTHOR_1.Books = [BOOK_1] AUTHOR_2.Books = [BOOK_2] // 查询的例子 // 找到所有AUTHOR_1写的书 for book in AUTHOR_1.Books: print(book.Title) // 获取BOOK_2的作者名 print(BOOK_2.Author.Name) 可以看到，在这种数据模型下，用户需要手动跟踪数据中存储的指针，直到找到自己的数据位置 1960 年代时，主要的数据库就是这种形式。这种形式的数据库中查询数据很复杂，和关系型数据库相比，不仅不能一次性使用外键连接多个表，而且查询数据的方式主要依赖代码实现，很难让用户单独使用命令查询。 在 1970 年代，随着关系代数的论文被发表，关系型数据库的概念开始兴起。我们今天所熟悉的 SQL 也被发明了。 IBM 的 System R 是第一个实现了关系代数模型的数据库产品。不过，由于当时的计算机尚未普及，对数据库系统系统的需求基本还停留在大型公司，其他大部分公司没有对数据库产品的需求。但 1970 年代的意义是重大的，因为关系型数据库这一时至今日仍然流行的数据模型就是在那时被确立的。 当然，尽管有了关系型数据库的雏形，当时的数据库系统还有很多基础研究没有完成。举例来说，对于数据库系统应该如何处理并发请求，如何管理锁来避免用户数据出现问题，直到 1990 年代才有系统性的论文出现。 随着计算机和互联网的普及，数据库系统不再是单纯的为大公司服务的昂贵系统，举例来说，1995 年微软发布了 Microsoft SQL Server ，这是一款能够运行在普通个人计算机上的数据库管理系统，而随着互联网的发展，越来越多的网站被建立起来，对数据库系统的需求激增，因此，以 MySQL 、MsSQL 、Postgres 等为代表的可以运行在普通个人计算机上的数据库系统从 1990 年代开始流行。 3.1.1.2 关系型数据库 在 1990 年代流行的数据库就是关系型数据库了，这个时候的数据库已经和今天大家熟悉的数据库很相似，我就不多做介绍。需要指出的是，今天大家很熟悉的 MySQL 在当时功能十分简单，是一个类似 KV数据库 的数据库。在 Innobase 将 innodb 捐献给 MySQL 之后， MySQL 才拥有了今天这些大家熟悉的功能。在 InnoDB 之前， MySQL 的默认存储引擎 MyISAM 不支持外键这种基本的关系型数据库功能，也不支持行锁这种基础的并发控制，是一个功能相对较弱的数据库。 3.1.1.3 NoSQL与NewSQL 在关系型数据库流行之后，随着互联网的进一步发展，对数据库系统也提出了新的要求，例如，非结构化数据存储，或者是大量数据的分区存储、分析能力，这些不是传统的关系型数据库能够支持的。因此，随后的数据库发展朝着两个方向进行： 第一个方向是发明各种新型的数据模型，例如文档数据库、图数据库，这些基于特定数据模型的数据库在特定的应用场景下相较关系型数据库有更大的优势。 第二个方向是进行数据库架构的演变，以支持不同的场景和灵活的性能要求，例如 Google 的 Spanner 就是典型的一种分布式、超大型数据库。 3.2 数据库系统的模块 不论数据库系统有哪些功能、实现哪种数据模型，在一些地方始终是相通的。本文介绍数据库系统通常的架构是什么样的。 我们来考虑一个基本的数据库系统，它至少包含以下两个部分： 用来处理用户请求的部分 用来管理数据存储的部分 通常，第一个部分被称为数据库系统的前端，而第二个部分被称为数据库系统的后端。 接下来， 我们分别考察这两个部分。 3.2.1 数据库的前端 3.2.1.1 查询解析器 这部分需要解析用户输入的命令，判断用户命令的合法性，举例来说： FELECT * FROM table1 LIMIT 0,10 这句 SQL 命令就不是一句合法的 SQL 命令，因为实际上不存在 FELECT 这一关键词 事实上，市面上的大部分数据库前端都会将用户输入的命令解析成抽象语法树 (AST) ，供后端处理，举例来说，下面是一颗解析 SQL 的 AST ： &lt;select-statement&gt; ├── &lt;column-list&gt; │ └── &lt;column-name&gt; │ └── name ├── &lt;table-name&gt; │ └── students └── &lt;condition&gt; ├── &lt;expression&gt; │ ├── &lt;MARK&gt; │ │ └── age │ ├── &lt;OP&gt; │ │ └── &gt; │ └── &lt;CONST&gt; │ └── &#39;18&#39; ├── &lt;logical-op&gt; │ └── AND └── &lt;expression&gt; ├── &lt;MARK&gt; │ └── gender ├── &lt;OP&gt; │ └── = └── &lt;CONST&gt; └── &#39;M&#39; 3.2.1.2 查询优化器 这部分做的事情主要是对用户输入的查询命令进行一个优化，需要注意的是，在数据库的后端实际上也存在执行计划的优化操作，这部分仅仅讨论的是对 AST 的优化操作。 例如，考虑这么一句 SQL ： SELECT * FROM table1 WHERE col1 &gt;= 10 AND col1 &lt;= 10 这句 SQL 实际上可以被等价优化成： SELECT * FROM table1 WHERE col1 = 10 这种基于 AST 的纯粹优化有很多好处，举例来说，如果不进行这样的优化，那么数据库后端在执行这个查询的时候大概率在执行的时候是这么执行的： 先找出所有满足 col1 &gt;= 10 或者 col1 &lt;= 10 的记录，然后检查是否满足其他条件。 这种查询显然是十分低效的，远不如根据 AST 优化后的结果。 3.2.2 数据库的后端 3.2.2.1 系统字典 数据库系统要对外维持自己的数据模型，就需要维护一些特定的信息。举例来说，如果是一个关系型的数据库，就需要维护自己目前库中有哪些表，表中有什么字段，哪些字段上存在索引这些信息。这一类的信息我们统称为数据库的多数据字典信息，属于是数据库系统自行维护的数据库元信息。数据库很大程度上需要依靠这些元信息来判断查询是否合法，以及如何执行查询。举例来说：当用户需要根据某一条件进行某一查询时，数据库需要根据元信息判断条件字段上是否存在索引，以此来决策具体的执行计划： SELECT * FROM table1 WHERE col1 = 10 对于这句查询语句，数据库系统就需要根据元信息来查询这么几个点： table1 是否存在 table1中有哪些字段 table1的数据存储在哪里 col1上是否有索引 3.2.2.2 查询计划器 查询计划器是所有数据库系统中最为复杂的部分，用于将逻辑上用户需要进行的查询计划转化为物理的执行计划，要明确到需要根据什么查数据，查什么数据，查到了数据之后进行怎么样的处理，具体的算子下沉还是上升等等问题，生成和优化物理执行计划本身是一个NP问题，这也是各个高性能数据库的技术核心。 在用户输入的命令被解析成 AST 并且通过数据字典的基本校验后，就进入到了查询计划器当中。 举例来说，考虑这么一条 SQL ： SELECT * FROM table1 WHERE col1 &gt;= 10 AND col2 &lt;= 10 这里其实有三条明显的执行路径： 直接扫描全部数据，然后根据条件筛选 根据索引拉出所有 col1 &gt;= 10 的数据，然后筛选满足 col2 &lt;= 10 的 根据索引拉出所有 col2&lt;=10 的数据，然后筛选满足 col1&gt;=10 的 哪个执行方案才是更优的呢？这就需要一些额外的信息辅助判断了： 例如，如果我们知道 col1&gt;=10 的数据只有大概 10 条，而 col2&lt;=10 的数据有 100000 条，那么显然第二个执行计划是更好的 反之，如果我们知道 col2&lt;=10 的数据明显少于 col1&gt;=10 的，那么显然第三个执行计划成本就更低 当然，如果说 col1 、col2 上不存在索引，或者说表的数据量很小，由于 id 在我们的数据库里是聚簇索引，不需要回盘查第二次，那可能直接拉所有的数据是更好的 3.2.2.3 事务管理器、锁管理器、并发控制器 这一部分，主要是大部分数据库都保有的、为了维持系统正确性、提供并发安全等而提供的机制，如果你的数据库要支持一些并发和隔离特性，那么需要一些额外的组件来支持数据库的正常工作。 这部分是一个比较复杂的问题，举例来说，对于以下2个同时执行的事务： SELECT * FROM table1 WHERE col1 = 10 FOR UPDATE SELECT * FROM table1 WHERE col2 = 10 FOR UPDATE SELECT * FROM table1 WHERE col1 = 10 FOR UPDATE SELECT * FROM table1 WHERE col2 = 10 FOR UPDATE 这 2 个事务就会出现互相等待对方释放锁的情况，进而造成死锁，这是不可接受的情况，需要有一个事务主动回滚，才能解决这一问题。 同样地，一些复杂的并发场景需要数据库系统主动识别才能避免问题发生，例如： SELECT id FROM table1 WHERE col1 = 10; -- 事务1，结果id=10 UPDATE table1 SET col1 = col1 + 10 WHERE col1 = 10; -- 事务2，提交 UPDATE table1 SET col1 = (10) + 10 WHERE id = 10; -- 事务1，提交 上述的问题就是一个明显的并发问题，事务1读取并使用过期的值来对数据进行更新。 由于这部分的内容相对比较复杂，要系统性的描述需要比较大的篇幅，在之后的内容中会进一步进行讨论。目前仅仅讨论到存在的问题和需要引入解决这些问题的组件。 3.2.2.4 缓存池 当执行计划被确定之后，就会对硬盘进行大量的 io操作 ，理论上，这些 io操作 很可能是随机的，至少也是随机混合的，这一类的读写模式对硬盘不友好，而实际上，即使这种模式对硬盘是友好的，硬盘的数据读取时间对于 CPU 来说也是十分漫长的。 图 3.1: 各种介质的延迟 图源 https://blog.bytebytego.com/p/ep22-latency-numbers-you-should-know 因此，所有的io操作最好是在内存中进行，由缓存池负责对硬盘的实际io读写调度 3.2.2.5 索引 数据库系统大量需要索引来辅助查找和存储数据，如果没有索引的帮助，数据库系统每次查找数据时只能对所有数据进行遍历，这是不可接受的。而目前常见的两种用于在硬盘数据上建立索引算法是 B树 (包括 B+树 等各种衍生)和 SSTable 。这些算法不仅是要尽可能高校地满足各类查询和插入需求，更重要的是要能够契合硬盘的硬件特性，尽可能减少读取硬盘的次数，一次尽可能多的读取数据而不是多次读取少量数据。 3.2.2.6 物理文件管理器 最后我们要提到的是物理文件管理模块，这里的模块负责的是硬盘空间的管理，这也是一个相对来说有一些复杂的问题。 举例来说，考虑我们需要向数据库存储一份数据，这份数据长 1000 个字节，那么存储引擎就需要考虑几个问题： 在哪里存这份数据？空间如何分配？ 如果有数据最近被删除了，怎么回收之前的数据供使用？ 怎么样存储数据才能尽可能提高查询效率？ 这些问题一定程度上也决定了数据库的性能表现 以上是对数据库系统各个常见模块的一些介绍，这些内容对理解接下来的行文思路会有很大帮助。 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
